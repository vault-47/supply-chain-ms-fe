/* tslint:disable */
/* eslint-disable */
/**
 * Supply chain API
 * This is API for supply chain management system
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface AuthControllerRegister200Response
 */
export interface AuthControllerRegister200Response {
  /**
   *
   * @type {UserResponseDto}
   * @memberof AuthControllerRegister200Response
   */
  data?: UserResponseDto;
  /**
   *
   * @type {string}
   * @memberof AuthControllerRegister200Response
   */
  message?: string;
  /**
   *
   * @type {boolean}
   * @memberof AuthControllerRegister200Response
   */
  status?: boolean;
}
/**
 *
 * @export
 * @interface BaseResponseDto
 */
export interface BaseResponseDto {
  /**
   *
   * @type {object}
   * @memberof BaseResponseDto
   */
  data?: object;
  /**
   *
   * @type {string}
   * @memberof BaseResponseDto
   */
  message?: string;
  /**
   *
   * @type {boolean}
   * @memberof BaseResponseDto
   */
  status?: boolean;
}
/**
 *
 * @export
 * @interface InvitationResponseDto
 */
export interface InvitationResponseDto {
  /**
   *
   * @type {string}
   * @memberof InvitationResponseDto
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof InvitationResponseDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof InvitationResponseDto
   */
  role: string;
  /**
   *
   * @type {string}
   * @memberof InvitationResponseDto
   */
  created_at: string;
}
/**
 *
 * @export
 * @interface InviteUserRequestDto
 */
export interface InviteUserRequestDto {
  /**
   * email
   * @type {string}
   * @memberof InviteUserRequestDto
   */
  email: string;
  /**
   * role
   * @type {string}
   * @memberof InviteUserRequestDto
   */
  role: string;
}
/**
 *
 * @export
 * @interface InvitesControllerInvites200Response
 */
export interface InvitesControllerInvites200Response {
  /**
   *
   * @type {Array<InvitationResponseDto>}
   * @memberof InvitesControllerInvites200Response
   */
  data: Array<InvitationResponseDto>;
  /**
   *
   * @type {PaginationMetaDto}
   * @memberof InvitesControllerInvites200Response
   */
  meta: PaginationMetaDto;
  /**
   *
   * @type {boolean}
   * @memberof InvitesControllerInvites200Response
   */
  status?: boolean;
  /**
   *
   * @type {string}
   * @memberof InvitesControllerInvites200Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface LoginRequestDto
 */
export interface LoginRequestDto {
  /**
   * email
   * @type {string}
   * @memberof LoginRequestDto
   */
  email: string;
  /**
   * password
   * @type {string}
   * @memberof LoginRequestDto
   */
  password: string;
}
/**
 *
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
  /**
   *
   * @type {string}
   * @memberof LoginResponseDto
   */
  access_token?: string;
}
/**
 *
 * @export
 * @interface LoginResponseWrapperDto
 */
export interface LoginResponseWrapperDto {
  /**
   *
   * @type {LoginResponseDto}
   * @memberof LoginResponseWrapperDto
   */
  data?: LoginResponseDto;
  /**
   *
   * @type {string}
   * @memberof LoginResponseWrapperDto
   */
  message?: string;
  /**
   *
   * @type {boolean}
   * @memberof LoginResponseWrapperDto
   */
  status?: boolean;
}
/**
 *
 * @export
 * @interface PaginatedResponseDto
 */
export interface PaginatedResponseDto {
  /**
   *
   * @type {Array<Array<string>>}
   * @memberof PaginatedResponseDto
   */
  data: Array<Array<string>>;
  /**
   *
   * @type {PaginationMetaDto}
   * @memberof PaginatedResponseDto
   */
  meta: PaginationMetaDto;
}
/**
 *
 * @export
 * @interface PaginationMetaDto
 */
export interface PaginationMetaDto {
  /**
   *
   * @type {number}
   * @memberof PaginationMetaDto
   */
  totalItems: number;
  /**
   *
   * @type {number}
   * @memberof PaginationMetaDto
   */
  itemCount: number;
  /**
   *
   * @type {number}
   * @memberof PaginationMetaDto
   */
  itemsPerPage: number;
  /**
   *
   * @type {number}
   * @memberof PaginationMetaDto
   */
  totalPages: number;
  /**
   *
   * @type {number}
   * @memberof PaginationMetaDto
   */
  currentPage: number;
}
/**
 *
 * @export
 * @interface RegistrationRequestDto
 */
export interface RegistrationRequestDto {
  /**
   * email
   * @type {string}
   * @memberof RegistrationRequestDto
   */
  email: string;
  /**
   * password
   * @type {string}
   * @memberof RegistrationRequestDto
   */
  password: string;
  /**
   * Repeat password
   * @type {string}
   * @memberof RegistrationRequestDto
   */
  repeat_password: string;
  /**
   * first_name
   * @type {string}
   * @memberof RegistrationRequestDto
   */
  first_name: string;
  /**
   * last_name
   * @type {string}
   * @memberof RegistrationRequestDto
   */
  last_name: string;
  /**
   * role
   * @type {string}
   * @memberof RegistrationRequestDto
   */
  role: string;
}
/**
 *
 * @export
 * @interface RequestQuoteRequestDto
 */
export interface RequestQuoteRequestDto {
  /**
   * vendor_uid
   * @type {string}
   * @memberof RequestQuoteRequestDto
   */
  vendor_uid: string;
  /**
   * origin_address
   * @type {string}
   * @memberof RequestQuoteRequestDto
   */
  origin_address: string;
  /**
   * destination_address
   * @type {string}
   * @memberof RequestQuoteRequestDto
   */
  destination_address: string;
  /**
   * distance_km
   * @type {number}
   * @memberof RequestQuoteRequestDto
   */
  distance_km: number;
  /**
   * weight_kg
   * @type {number}
   * @memberof RequestQuoteRequestDto
   */
  weight_kg: number;
  /**
   * goods_type
   * @type {string}
   * @memberof RequestQuoteRequestDto
   */
  goods_type: string;
  /**
   * additional_note
   * @type {string}
   * @memberof RequestQuoteRequestDto
   */
  additional_note: string;
  /**
   * urgency
   * @type {string}
   * @memberof RequestQuoteRequestDto
   */
  urgency: string;
}
/**
 *
 * @export
 * @interface SendInvitationResponseDto
 */
export interface SendInvitationResponseDto {
  /**
   *
   * @type {string}
   * @memberof SendInvitationResponseDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SendInvitationResponseDto
   */
  role: string;
}
/**
 *
 * @export
 * @interface SendInvitationResponseWrapperDto
 */
export interface SendInvitationResponseWrapperDto {
  /**
   *
   * @type {SendInvitationResponseDto}
   * @memberof SendInvitationResponseWrapperDto
   */
  data?: SendInvitationResponseDto;
  /**
   *
   * @type {string}
   * @memberof SendInvitationResponseWrapperDto
   */
  message?: string;
  /**
   *
   * @type {boolean}
   * @memberof SendInvitationResponseWrapperDto
   */
  status?: boolean;
}
/**
 *
 * @export
 * @interface UserAcceptInviteRequestDto
 */
export interface UserAcceptInviteRequestDto {
  /**
   * email
   * @type {string}
   * @memberof UserAcceptInviteRequestDto
   */
  email: string;
  /**
   * password
   * @type {string}
   * @memberof UserAcceptInviteRequestDto
   */
  password: string;
  /**
   * Repeat password
   * @type {string}
   * @memberof UserAcceptInviteRequestDto
   */
  repeat_password: string;
  /**
   * first_name
   * @type {string}
   * @memberof UserAcceptInviteRequestDto
   */
  first_name: string;
  /**
   * last_name
   * @type {string}
   * @memberof UserAcceptInviteRequestDto
   */
  last_name: string;
  /**
   * role
   * @type {string}
   * @memberof UserAcceptInviteRequestDto
   */
  role: string;
}
/**
 *
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
  /**
   *
   * @type {object}
   * @memberof UserResponseDto
   */
  uid?: object;
  /**
   *
   * @type {string}
   * @memberof UserResponseDto
   */
  first_name?: string;
  /**
   *
   * @type {string}
   * @memberof UserResponseDto
   */
  last_name?: string;
  /**
   *
   * @type {object}
   * @memberof UserResponseDto
   */
  email?: object;
  /**
   *
   * @type {string}
   * @memberof UserResponseDto
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof UserResponseDto
   */
  account_status?: string;
  /**
   *
   * @type {object}
   * @memberof UserResponseDto
   */
  created_at?: object;
}
/**
 *
 * @export
 * @interface UsersControllerGetUsers200Response
 */
export interface UsersControllerGetUsers200Response {
  /**
   *
   * @type {Array<UserResponseDto>}
   * @memberof UsersControllerGetUsers200Response
   */
  data: Array<UserResponseDto>;
  /**
   *
   * @type {PaginationMetaDto}
   * @memberof UsersControllerGetUsers200Response
   */
  meta: PaginationMetaDto;
  /**
   *
   * @type {boolean}
   * @memberof UsersControllerGetUsers200Response
   */
  status?: boolean;
  /**
   *
   * @type {string}
   * @memberof UsersControllerGetUsers200Response
   */
  message?: string;
}

/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = (configuration?: Configuration) => ({
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  appControllerGetHello: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
});

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = (configuration?: Configuration) => {
  const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerGetHello(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.appControllerGetHello(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AppApi.appControllerGetHello"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) => {
  const localVarFp = AppApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .appControllerGetHello(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppApi
   */
  public appControllerGetHello(options?: RawAxiosRequestConfig) {
    return AppApiFp(this.configuration)
      .appControllerGetHello(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = (configuration?: Configuration) => ({
  /**
   *
   * @summary Grant access to all users
   * @param {LoginRequestDto} loginRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  authControllerLogin: async (
    loginRequestDto: LoginRequestDto,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    // verify required parameter 'loginRequestDto' is not null or undefined
    assertParamExists(
      "authControllerLogin",
      "loginRequestDto",
      loginRequestDto,
    );
    const localVarPath = `/api/auth/login`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };
    localVarRequestOptions.data = serializeDataIfNeeded(
      loginRequestDto,
      localVarRequestOptions,
      configuration,
    );

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary SUPER_ADMIN registration
   * @param {RegistrationRequestDto} registrationRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  authControllerRegister: async (
    registrationRequestDto: RegistrationRequestDto,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    // verify required parameter 'registrationRequestDto' is not null or undefined
    assertParamExists(
      "authControllerRegister",
      "registrationRequestDto",
      registrationRequestDto,
    );
    const localVarPath = `/api/auth/register`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };
    localVarRequestOptions.data = serializeDataIfNeeded(
      registrationRequestDto,
      localVarRequestOptions,
      configuration,
    );

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
});

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = (configuration?: Configuration) => {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Grant access to all users
     * @param {LoginRequestDto} loginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogin(
      loginRequestDto: LoginRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<LoginResponseWrapperDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerLogin(
          loginRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.authControllerLogin"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary SUPER_ADMIN registration
     * @param {RegistrationRequestDto} registrationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerRegister(
      registrationRequestDto: RegistrationRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AuthControllerRegister200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerRegister(
          registrationRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.authControllerRegister"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) => {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     *
     * @summary Grant access to all users
     * @param {LoginRequestDto} loginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin(
      loginRequestDto: LoginRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<LoginResponseWrapperDto> {
      return localVarFp
        .authControllerLogin(loginRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary SUPER_ADMIN registration
     * @param {RegistrationRequestDto} registrationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerRegister(
      registrationRequestDto: RegistrationRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthControllerRegister200Response> {
      return localVarFp
        .authControllerRegister(registrationRequestDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Grant access to all users
   * @param {LoginRequestDto} loginRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerLogin(
    loginRequestDto: LoginRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authControllerLogin(loginRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary SUPER_ADMIN registration
   * @param {RegistrationRequestDto} registrationRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerRegister(
    registrationRequestDto: RegistrationRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authControllerRegister(registrationRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InvitesApi - axios parameter creator
 * @export
 */
export const InvitesApiAxiosParamCreator = (configuration?: Configuration) => ({
  /**
   *
   * @summary User i.e admins, shippers and vendors complete onboarding
   * @param {string} inviteCode invite code
   * @param {UserAcceptInviteRequestDto} userAcceptInviteRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  invitesControllerAcceptInvite: async (
    inviteCode: string,
    userAcceptInviteRequestDto: UserAcceptInviteRequestDto,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    // verify required parameter 'inviteCode' is not null or undefined
    assertParamExists(
      "invitesControllerAcceptInvite",
      "inviteCode",
      inviteCode,
    );
    // verify required parameter 'userAcceptInviteRequestDto' is not null or undefined
    assertParamExists(
      "invitesControllerAcceptInvite",
      "userAcceptInviteRequestDto",
      userAcceptInviteRequestDto,
    );
    const localVarPath = `/api/invites/{invite_code}/accept`.replace(
      `{${"invite_code"}}`,
      encodeURIComponent(String(inviteCode)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };
    localVarRequestOptions.data = serializeDataIfNeeded(
      userAcceptInviteRequestDto,
      localVarRequestOptions,
      configuration,
    );

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Admins send invite to ADMIN, SHIPPER and VENDOR
   * @param {InviteUserRequestDto} inviteUserRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  invitesControllerInvite: async (
    inviteUserRequestDto: InviteUserRequestDto,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    // verify required parameter 'inviteUserRequestDto' is not null or undefined
    assertParamExists(
      "invitesControllerInvite",
      "inviteUserRequestDto",
      inviteUserRequestDto,
    );
    const localVarPath = `/api/invites`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };
    localVarRequestOptions.data = serializeDataIfNeeded(
      inviteUserRequestDto,
      localVarRequestOptions,
      configuration,
    );

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Returns list of invites. Accessible only by SUPER_ADMIN and ADMIN
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {InvitesControllerInvitesRoleEnum} [role]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  invitesControllerInvites: async (
    page?: number,
    pageSize?: number,
    role?: InvitesControllerInvitesRoleEnum,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/invites`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    if (page !== undefined) {
      localVarQueryParameter["page"] = page;
    }

    if (pageSize !== undefined) {
      localVarQueryParameter["pageSize"] = pageSize;
    }

    if (role !== undefined) {
      localVarQueryParameter["role"] = role;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
});

/**
 * InvitesApi - functional programming interface
 * @export
 */
export const InvitesApiFp = (configuration?: Configuration) => {
  const localVarAxiosParamCreator = InvitesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary User i.e admins, shippers and vendors complete onboarding
     * @param {string} inviteCode invite code
     * @param {UserAcceptInviteRequestDto} userAcceptInviteRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invitesControllerAcceptInvite(
      inviteCode: string,
      userAcceptInviteRequestDto: UserAcceptInviteRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AuthControllerRegister200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.invitesControllerAcceptInvite(
          inviteCode,
          userAcceptInviteRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["InvitesApi.invitesControllerAcceptInvite"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Admins send invite to ADMIN, SHIPPER and VENDOR
     * @param {InviteUserRequestDto} inviteUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invitesControllerInvite(
      inviteUserRequestDto: InviteUserRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SendInvitationResponseWrapperDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.invitesControllerInvite(
          inviteUserRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["InvitesApi.invitesControllerInvite"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Returns list of invites. Accessible only by SUPER_ADMIN and ADMIN
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {InvitesControllerInvitesRoleEnum} [role]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invitesControllerInvites(
      page?: number,
      pageSize?: number,
      role?: InvitesControllerInvitesRoleEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InvitesControllerInvites200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.invitesControllerInvites(
          page,
          pageSize,
          role,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["InvitesApi.invitesControllerInvites"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * InvitesApi - factory interface
 * @export
 */
export const InvitesApiFactory = (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) => {
  const localVarFp = InvitesApiFp(configuration);
  return {
    /**
     *
     * @summary User i.e admins, shippers and vendors complete onboarding
     * @param {string} inviteCode invite code
     * @param {UserAcceptInviteRequestDto} userAcceptInviteRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invitesControllerAcceptInvite(
      inviteCode: string,
      userAcceptInviteRequestDto: UserAcceptInviteRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthControllerRegister200Response> {
      return localVarFp
        .invitesControllerAcceptInvite(
          inviteCode,
          userAcceptInviteRequestDto,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Admins send invite to ADMIN, SHIPPER and VENDOR
     * @param {InviteUserRequestDto} inviteUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invitesControllerInvite(
      inviteUserRequestDto: InviteUserRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SendInvitationResponseWrapperDto> {
      return localVarFp
        .invitesControllerInvite(inviteUserRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns list of invites. Accessible only by SUPER_ADMIN and ADMIN
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {InvitesControllerInvitesRoleEnum} [role]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invitesControllerInvites(
      page?: number,
      pageSize?: number,
      role?: InvitesControllerInvitesRoleEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<InvitesControllerInvites200Response> {
      return localVarFp
        .invitesControllerInvites(page, pageSize, role, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * InvitesApi - object-oriented interface
 * @export
 * @class InvitesApi
 * @extends {BaseAPI}
 */
export class InvitesApi extends BaseAPI {
  /**
   *
   * @summary User i.e admins, shippers and vendors complete onboarding
   * @param {string} inviteCode invite code
   * @param {UserAcceptInviteRequestDto} userAcceptInviteRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvitesApi
   */
  public invitesControllerAcceptInvite(
    inviteCode: string,
    userAcceptInviteRequestDto: UserAcceptInviteRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return InvitesApiFp(this.configuration)
      .invitesControllerAcceptInvite(
        inviteCode,
        userAcceptInviteRequestDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Admins send invite to ADMIN, SHIPPER and VENDOR
   * @param {InviteUserRequestDto} inviteUserRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvitesApi
   */
  public invitesControllerInvite(
    inviteUserRequestDto: InviteUserRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return InvitesApiFp(this.configuration)
      .invitesControllerInvite(inviteUserRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns list of invites. Accessible only by SUPER_ADMIN and ADMIN
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {InvitesControllerInvitesRoleEnum} [role]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvitesApi
   */
  public invitesControllerInvites(
    page?: number,
    pageSize?: number,
    role?: InvitesControllerInvitesRoleEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return InvitesApiFp(this.configuration)
      .invitesControllerInvites(page, pageSize, role, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const InvitesControllerInvitesRoleEnum = {
  Admin: "ADMIN",
  Vendor: "VENDOR",
  Shipper: "SHIPPER",
  Dispatcher: "DISPATCHER",
} as const;
export type InvitesControllerInvitesRoleEnum =
  (typeof InvitesControllerInvitesRoleEnum)[keyof typeof InvitesControllerInvitesRoleEnum];

/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = (configuration?: Configuration) => ({
  /**
   *
   * @summary Current user profile
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  profileControllerProfile: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/profile`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
});

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = (configuration?: Configuration) => {
  const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profileControllerProfile(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AuthControllerRegister200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profileControllerProfile(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProfileApi.profileControllerProfile"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) => {
  const localVarFp = ProfileApiFp(configuration);
  return {
    /**
     *
     * @summary Current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profileControllerProfile(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthControllerRegister200Response> {
      return localVarFp
        .profileControllerProfile(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
  /**
   *
   * @summary Current user profile
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public profileControllerProfile(options?: RawAxiosRequestConfig) {
    return ProfileApiFp(this.configuration)
      .profileControllerProfile(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * QuotesApi - axios parameter creator
 * @export
 */
export const QuotesApiAxiosParamCreator = (configuration?: Configuration) => ({
  /**
   *
   * @summary Accept quote 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  quotesControllerAcceptQuote: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/quotes/{id}/accept`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Create quote 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  quotesControllerCreateQuote: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/quotes`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Fetch quote details 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  quotesControllerGetQuote: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/quotes/{id}`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Fetch quotes 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  quotesControllerGetQuotes: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/quotes`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Reject quote 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  quotesControllerRejectQuote: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/quotes/{id}/reject`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
});

/**
 * QuotesApi - functional programming interface
 * @export
 */
export const QuotesApiFp = (configuration?: Configuration) => {
  const localVarAxiosParamCreator = QuotesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Accept quote 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quotesControllerAcceptQuote(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.quotesControllerAcceptQuote(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QuotesApi.quotesControllerAcceptQuote"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create quote 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quotesControllerCreateQuote(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.quotesControllerCreateQuote(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QuotesApi.quotesControllerCreateQuote"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Fetch quote details 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quotesControllerGetQuote(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.quotesControllerGetQuote(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QuotesApi.quotesControllerGetQuote"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Fetch quotes 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quotesControllerGetQuotes(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.quotesControllerGetQuotes(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QuotesApi.quotesControllerGetQuotes"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Reject quote 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quotesControllerRejectQuote(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.quotesControllerRejectQuote(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QuotesApi.quotesControllerRejectQuote"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * QuotesApi - factory interface
 * @export
 */
export const QuotesApiFactory = (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) => {
  const localVarFp = QuotesApiFp(configuration);
  return {
    /**
     *
     * @summary Accept quote 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quotesControllerAcceptQuote(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .quotesControllerAcceptQuote(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create quote 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quotesControllerCreateQuote(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .quotesControllerCreateQuote(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Fetch quote details 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quotesControllerGetQuote(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .quotesControllerGetQuote(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Fetch quotes 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quotesControllerGetQuotes(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .quotesControllerGetQuotes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Reject quote 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quotesControllerRejectQuote(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .quotesControllerRejectQuote(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * QuotesApi - object-oriented interface
 * @export
 * @class QuotesApi
 * @extends {BaseAPI}
 */
export class QuotesApi extends BaseAPI {
  /**
   *
   * @summary Accept quote 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public quotesControllerAcceptQuote(options?: RawAxiosRequestConfig) {
    return QuotesApiFp(this.configuration)
      .quotesControllerAcceptQuote(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create quote 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public quotesControllerCreateQuote(options?: RawAxiosRequestConfig) {
    return QuotesApiFp(this.configuration)
      .quotesControllerCreateQuote(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Fetch quote details 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public quotesControllerGetQuote(options?: RawAxiosRequestConfig) {
    return QuotesApiFp(this.configuration)
      .quotesControllerGetQuote(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Fetch quotes 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public quotesControllerGetQuotes(options?: RawAxiosRequestConfig) {
    return QuotesApiFp(this.configuration)
      .quotesControllerGetQuotes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Reject quote 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public quotesControllerRejectQuote(options?: RawAxiosRequestConfig) {
    return QuotesApiFp(this.configuration)
      .quotesControllerRejectQuote(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RequestQuotesApi - axios parameter creator
 * @export
 */
export const RequestQuotesApiAxiosParamCreator = (
  configuration?: Configuration,
) => ({
  /**
   *
   * @summary List requested quotes 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  requestQuotesControllerListRequestedQuotes: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/request-quotes`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Request quote 🚧
   * @param {RequestQuoteRequestDto} requestQuoteRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  requestQuotesControllerRequestQuote: async (
    requestQuoteRequestDto: RequestQuoteRequestDto,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    // verify required parameter 'requestQuoteRequestDto' is not null or undefined
    assertParamExists(
      "requestQuotesControllerRequestQuote",
      "requestQuoteRequestDto",
      requestQuoteRequestDto,
    );
    const localVarPath = `/api/request-quotes`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };
    localVarRequestOptions.data = serializeDataIfNeeded(
      requestQuoteRequestDto,
      localVarRequestOptions,
      configuration,
    );

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Details of requested quote, should also return corresponding quotes 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  requestQuotesControllerRequestQuoteDetail: async (
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/request-quotes/{id}`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
});

/**
 * RequestQuotesApi - functional programming interface
 * @export
 */
export const RequestQuotesApiFp = (configuration?: Configuration) => {
  const localVarAxiosParamCreator =
    RequestQuotesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary List requested quotes 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestQuotesControllerListRequestedQuotes(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestQuotesControllerListRequestedQuotes(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "RequestQuotesApi.requestQuotesControllerListRequestedQuotes"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Request quote 🚧
     * @param {RequestQuoteRequestDto} requestQuoteRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestQuotesControllerRequestQuote(
      requestQuoteRequestDto: RequestQuoteRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RequestQuoteRequestDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestQuotesControllerRequestQuote(
          requestQuoteRequestDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "RequestQuotesApi.requestQuotesControllerRequestQuote"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Details of requested quote, should also return corresponding quotes 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestQuotesControllerRequestQuoteDetail(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestQuotesControllerRequestQuoteDetail(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "RequestQuotesApi.requestQuotesControllerRequestQuoteDetail"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RequestQuotesApi - factory interface
 * @export
 */
export const RequestQuotesApiFactory = (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) => {
  const localVarFp = RequestQuotesApiFp(configuration);
  return {
    /**
     *
     * @summary List requested quotes 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestQuotesControllerListRequestedQuotes(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .requestQuotesControllerListRequestedQuotes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Request quote 🚧
     * @param {RequestQuoteRequestDto} requestQuoteRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestQuotesControllerRequestQuote(
      requestQuoteRequestDto: RequestQuoteRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<RequestQuoteRequestDto> {
      return localVarFp
        .requestQuotesControllerRequestQuote(requestQuoteRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Details of requested quote, should also return corresponding quotes 🚧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestQuotesControllerRequestQuoteDetail(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .requestQuotesControllerRequestQuoteDetail(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RequestQuotesApi - object-oriented interface
 * @export
 * @class RequestQuotesApi
 * @extends {BaseAPI}
 */
export class RequestQuotesApi extends BaseAPI {
  /**
   *
   * @summary List requested quotes 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestQuotesApi
   */
  public requestQuotesControllerListRequestedQuotes(
    options?: RawAxiosRequestConfig,
  ) {
    return RequestQuotesApiFp(this.configuration)
      .requestQuotesControllerListRequestedQuotes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Request quote 🚧
   * @param {RequestQuoteRequestDto} requestQuoteRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestQuotesApi
   */
  public requestQuotesControllerRequestQuote(
    requestQuoteRequestDto: RequestQuoteRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return RequestQuotesApiFp(this.configuration)
      .requestQuotesControllerRequestQuote(requestQuoteRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Details of requested quote, should also return corresponding quotes 🚧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestQuotesApi
   */
  public requestQuotesControllerRequestQuoteDetail(
    options?: RawAxiosRequestConfig,
  ) {
    return RequestQuotesApiFp(this.configuration)
      .requestQuotesControllerRequestQuoteDetail(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = (configuration?: Configuration) => ({
  /**
   *
   * @summary Activate user account. Accessible only by SUPER_ADMIN and ADMIN
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  usersControllerActivateUser: async (
    id: string,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    // verify required parameter 'id' is not null or undefined
    assertParamExists("usersControllerActivateUser", "id", id);
    const localVarPath = `/api/users/{id}/activate`.replace(
      `{${"id"}}`,
      encodeURIComponent(String(id)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Returns specific user. Accessible only by SUPER_ADMIN and ADMIN
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  usersControllerGetUser: async (
    id: string,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    // verify required parameter 'id' is not null or undefined
    assertParamExists("usersControllerGetUser", "id", id);
    const localVarPath = `/api/users/{id}`.replace(
      `{${"id"}}`,
      encodeURIComponent(String(id)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Returns list of users. Accessible only by SUPER_ADMIN and ADMIN
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {UsersControllerGetUsersRoleEnum} [role]
   * @param {UsersControllerGetUsersStatusEnum} [status]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  usersControllerGetUsers: async (
    page?: number,
    pageSize?: number,
    role?: UsersControllerGetUsersRoleEnum,
    status?: UsersControllerGetUsersStatusEnum,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    const localVarPath = `/api/users`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "GET",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    if (page !== undefined) {
      localVarQueryParameter["page"] = page;
    }

    if (pageSize !== undefined) {
      localVarQueryParameter["pageSize"] = pageSize;
    }

    if (role !== undefined) {
      localVarQueryParameter["role"] = role;
    }

    if (status !== undefined) {
      localVarQueryParameter["status"] = status;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
  /**
   *
   * @summary Suspend user account. Accessible only by SUPER_ADMIN and ADMIN
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  usersControllerSuspendUser: async (
    id: string,
    options: RawAxiosRequestConfig = {},
  ): Promise<RequestArgs> => {
    // verify required parameter 'id' is not null or undefined
    assertParamExists("usersControllerSuspendUser", "id", id);
    const localVarPath = `/api/users/{id}/suspend`.replace(
      `{${"id"}}`,
      encodeURIComponent(String(id)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
      baseOptions = configuration.baseOptions;
    }

    const localVarRequestOptions = {
      method: "POST",
      ...baseOptions,
      ...options,
    };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    // authentication bearer required
    // http bearer authentication required
    await setBearerAuthToObject(localVarHeaderParameter, configuration);

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions =
      baseOptions && baseOptions.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
      ...localVarHeaderParameter,
      ...headersFromBaseOptions,
      ...options.headers,
    };

    return {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions,
    };
  },
});

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = (configuration?: Configuration) => {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Activate user account. Accessible only by SUPER_ADMIN and ADMIN
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerActivateUser(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AuthControllerRegister200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerActivateUser(
          id,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.usersControllerActivateUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Returns specific user. Accessible only by SUPER_ADMIN and ADMIN
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerGetUser(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AuthControllerRegister200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerGetUser(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.usersControllerGetUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Returns list of users. Accessible only by SUPER_ADMIN and ADMIN
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {UsersControllerGetUsersRoleEnum} [role]
     * @param {UsersControllerGetUsersStatusEnum} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerGetUsers(
      page?: number,
      pageSize?: number,
      role?: UsersControllerGetUsersRoleEnum,
      status?: UsersControllerGetUsersStatusEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UsersControllerGetUsers200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerGetUsers(
          page,
          pageSize,
          role,
          status,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.usersControllerGetUsers"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Suspend user account. Accessible only by SUPER_ADMIN and ADMIN
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerSuspendUser(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AuthControllerRegister200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerSuspendUser(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.usersControllerSuspendUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) => {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Activate user account. Accessible only by SUPER_ADMIN and ADMIN
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerActivateUser(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthControllerRegister200Response> {
      return localVarFp
        .usersControllerActivateUser(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns specific user. Accessible only by SUPER_ADMIN and ADMIN
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUser(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthControllerRegister200Response> {
      return localVarFp
        .usersControllerGetUser(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns list of users. Accessible only by SUPER_ADMIN and ADMIN
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {UsersControllerGetUsersRoleEnum} [role]
     * @param {UsersControllerGetUsersStatusEnum} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUsers(
      page?: number,
      pageSize?: number,
      role?: UsersControllerGetUsersRoleEnum,
      status?: UsersControllerGetUsersStatusEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UsersControllerGetUsers200Response> {
      return localVarFp
        .usersControllerGetUsers(page, pageSize, role, status, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Suspend user account. Accessible only by SUPER_ADMIN and ADMIN
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSuspendUser(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthControllerRegister200Response> {
      return localVarFp
        .usersControllerSuspendUser(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Activate user account. Accessible only by SUPER_ADMIN and ADMIN
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerActivateUser(
    id: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerActivateUser(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns specific user. Accessible only by SUPER_ADMIN and ADMIN
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerGetUser(id: string, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersControllerGetUser(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns list of users. Accessible only by SUPER_ADMIN and ADMIN
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {UsersControllerGetUsersRoleEnum} [role]
   * @param {UsersControllerGetUsersStatusEnum} [status]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerGetUsers(
    page?: number,
    pageSize?: number,
    role?: UsersControllerGetUsersRoleEnum,
    status?: UsersControllerGetUsersStatusEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerGetUsers(page, pageSize, role, status, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Suspend user account. Accessible only by SUPER_ADMIN and ADMIN
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerSuspendUser(
    id: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerSuspendUser(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const UsersControllerGetUsersRoleEnum = {
  SuperAdmin: "SUPER_ADMIN",
  Admin: "ADMIN",
  Shipper: "SHIPPER",
  Vendor: "VENDOR",
  Dispatcher: "DISPATCHER",
} as const;
export type UsersControllerGetUsersRoleEnum =
  (typeof UsersControllerGetUsersRoleEnum)[keyof typeof UsersControllerGetUsersRoleEnum];
/**
 * @export
 */
export const UsersControllerGetUsersStatusEnum = {
  Active: "ACTIVE",
  Suspended: "SUSPENDED",
} as const;
export type UsersControllerGetUsersStatusEnum =
  (typeof UsersControllerGetUsersStatusEnum)[keyof typeof UsersControllerGetUsersStatusEnum];
